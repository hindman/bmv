--------
toc: Table of contents
--------

    toc                  | Table of contents
    todos                | TODOs
    road-map             | Road map
    usage                | Usage
    renaming-validations | Renaming validations
    dev-notes            | Dev notes
    other-tools          | Other tools

--------
todos: TODOs
--------

Remaining issues from testing/refactoring work:

    - Re-assess failure control, which is awkward:
        - The Failure types are just wrappers around strings.

            - Proliferation of types seems unnecessary.
            - Adn there's nearly[?] a 1-to-1 relationship between types and messages.

            - For example, rather than this:

                # Map each failure kind to its msg-fmt.
                FK = constants('FailureKinds', ...)

                # Instead of building messages in code and returning
                # a particular type of Failure.
                msg = FAIL.conflicting_controls.format(name1, name2)
                return OptsFailure(msg)

                # Delegate all of that to a general Failure class
                # that knows how to to the string building and kind-setting.
                return Failure(FT.conflicting_controls, name1, name2)

        - The related data structures and validation logic seem overly complex.
            - Figure out the underlying use-cases/needs. For example:
                - User supplies failure-control opts/names.
                    - We need to validate them for conflicts.
                    - And we need to store the configurations for ease of use later.
                - When a Failure is handled during prepare()
                    - We need to look up the failure-kind.
                    - And decide what to do.

    - Real command-line testing scenarios:
        - To exercise currently-uncoverable code.
        - To confirm that file system operations are in working order:
            - renaming
            - clobbering
            - creating parents

    ===========

    - Editing pass over code and tests:
        - organization
        - comments
        - naming
        - clarity/simplicity
        - Failure types: assess for consistency, naming, and usage in the code.
        - Reduce testing-code repetition.

    ===========

    - File operations can fail:
        - collecting input paths (eg, missing or unreadable input file-source).
        - writing to log

Project name change:
    - bmv is claimed [emailed maintainer: Nov 2; no reply].
    - Rename to mvs
    - Dependencies: drop attrs; re-create virtualenvs.

--------
road-map: Road map
--------

New validation issues to consider:
    - all paths must be non-empty

Case-change-only renamings.
    - Path(orig).rename(new): works
    - But existence checks do not respect case.

Logging: bootstrap (create $HOME/.bmv).
Logging: list.
Logging: prune.
Logging: undo operation.

Error handling:
    - If plan.rename_paths() raises, user has no idea whether/how-many
      paths were renamed before the failure.
    - One approach is to count N of paths actually renamed before the fail?

Other operations: copy, backup, link, chmod, touch, timestamps.

Option: --row-delimiter [default: tab]
Option: --path-delimiter [default: newline]
Option: --no-strip [default: paths are stripped]

Alternative dryrun output styles: should support the same behavior as input structures.

Complex failure/validation scenarios:
    - prior renaming would make subsequent renaming fail [eg, changing directory path before attempting a file rename]

Preferences.

--------
usage: Usage
--------

Usage components:

    PATHS     : positionals
    SOURCE    : PATHS | --stdin | --file PATH | --clipboard
    STRUCTURE : --rename CODE | --paragraphs | --pairs | --rows | --flat
    OTHER     : all other options

Usage schematic:

    bmv SOURCE [STRUCTURE] [OTHER]

Usage notes.

    User must provide exactly one source for input paths.

    The user must supply zero or one option defining the structure of the input
    path data.

    Structures for input path data:

        - Paragraphs: two Unix-style paragraphs, one for original paths, one for new paths.
        - Pairs: alternating lines (original, new, original, new, etc).
        - Rows: tab-delimited rows (original, tab, new).
        - Flat: original paths, then an equal number of new paths (blank lines irrelevant).

    The --rename option is considered structural:

        - It implies that the input path data consists solely of original paths.
        - The other structural options imply original-new pairs in one form or another.

--------
renaming-validations: Renaming validations
--------

Old-path and new-path differ for each pair.

Old-paths exist.

New-paths do not exist.

New-paths do not collide among themselves.

Directories of the new-paths exist.

--------
dev-notes: Dev notes
--------

Creating a new virtualenv:

    v='3.9.4'
    deactivate
    pyenv shell $v && pyenv versions
    mkvirtualenv bmv-$v
    pip install -U pip
    pip install -e .[dev,test] && pip list

Activate and run tests:

    - Basic:

        workon bmv-3.9.4
        pytest -s -v tests/

    - With invoke:

        inv test
        inv tox

    - With tox directly:

        pyenv shell 3.9.4  3.8.9  ...
        tox

Version bump:

    - Edit/commit all changes, including CHANGES and README.

    inv bump --kind major|minor|patch

Publish:

    inv dist [--publish] [--test]

Installing from test pypi:

    pip install --index-url https://test.pypi.org/simple/ bmv
    pip uninstall attrs short-con
    pip install attrs short-con

Tag file creation:

    inv tags

--------
other-tools: Other tools
--------

CLI tools:

  - rename

    - http://search.cpan.org/~pederst/rename-1.9/bin/rename.PL

    - Classic Perl renaming utility by Larry Wall, subsequently maintained
      (perhaps with minor enhancements) by others.

    - The core concept was to use a Perl expression to convert ORIG names to
      NEW names.

  - brn

    - http://search.cpan.org/~swestrup/App-FileTools-BulkRename-0.07/bin/brn

    - Enhancement of the Perl rename tool.

  - perlmv

    - http://search.cpan.org/dist/App-perlmv/bin/perlmv

    - Enhancement of the Perl rename tool.

    - Scriptlets directory where a user could store small bits of renaming
      logic. On the command-line, these common scenarios could be referenced by
      name.

  - pmv

    - http://search.cpan.org/~jv/File-PerlMove-0.06/script/pmv

    - Enhancement of the Perl rename tool.

  - renameutils

    - http://www.nongnu.org/renameutils/

    - Editor mode: open candidate renamings in text file; user edits and quits;
      then renaming occurs.

  - mmv

    - Unix mass move tool. Fairly basic.

    - Very little information available aside from some archived man pages.

  - rnm

    - https://github.com/neurobin/rnm

    - Many features, but nothing I haven't covered already.

    - A long and cryptic set of options, codes, and terminology.


GUI tools and OS-specific tools:

  - pyrenamer

    - https://github.com/SteveRyherd/pyRenamer

  - gprename

    - https://en.wikipedia.org/wiki/GPRename

  - krename

    - http://www.krename.net/home/

  - Metamorphose

    - https://github.com/metamorphose/metamorphose2

--------
failure-notes: Notes on Failure classes and failure-control
--------

constants.py
    FAIL: mapping: message-name => message
    CONTROLS: control-names
    CONTROLLABLES: mapping: control-problem-kind => (control-name, Failure-class)
    argparse config: control-problem-kinds, expressed as flag-options

data_objects.py

    Failure
    Failure subclasses
    RenamePair: has a Failure
    WrappedFailure: has a Failure, RenamePair-with-Failure  [ugh!]

utils.py

    validated_failure_controls():
        - uses CONTROLLABLES
        - returns dict or an OptsFailure
        - dict: failure-class => control-name

cli.py

    Need: Ability to generate all of the control-problem-kinds (as flags).

    Need: Ability to know when conflicting control-problem-kinds have been set
    True for the same problem-kind.

plan.py

    Need: When a problem occurs, ability to take a problem-kind and look up
    which control (if any) has been requested by user.

    Need: When a problem occurs, ability to create the right kind of problem
    with the appropriate message (which might be a simple string or a
    format-string needing further args).

    Dilemma: Does a RenamePair need a Failure, or vice-versa? WrappedFailure??

CONTROLS:
    skip
    keep
    create
    clobber

Current situation:

    Current name        | Controls      | Current msg-fmt
    ----------------------------------------------------------------------------------------------------
    equal               | skip          | orig_new_same
    missing             | skip          | orig_missing
    missing_parent      | skip, create  | new_parent_missing
    existing_new        | skip, clobber | new_exists
    colliding_new       | skip, clobber | new_collision
    failed_rename       | skip          | rename_code_invalid, rename_code_bad_return
    failed_filter       | skip, keep    | filter_code_invalid
    ----------------------------------------------------------------------------------------------------
    NoPathsFailure      | .             | no_paths_after_processing
    OptsFailure         | .             | conflicting_controls
    ParseFailure        | .             | no_input_paths, parsing_paragraphs, parsing_row, parsing_inequality
    UserCodeExecFailure | .             | [traceback]

Failure subclasses:

    NoPathsFailure         | no_paths_after_processing
    OptsFailure            | conflicting_controls
    ParseFailure           | no_input_paths, parsing_paragraphs, parsing_row, parsing_inequality
    UserCodeExecFailure    | [traceback]
    ----------------------------------------
    RpCollsionFailure      | .
    RpEqualFailure         | .
    RpExistsFailure        | .
    RpFilterFailure        | .
    RpMissingFailure       | .
    RpMissingParentFailure | .
    RpRenameFailure        | .
    ----------------------------------------
    WrappedFailure         | .



CONTROLLABLES:
    skip_equal            = (CONTROLS.skip, RpEqualFailure),
    skip_missing          = (CONTROLS.skip, RpMissingFailure),
    skip_missing_parent   = (CONTROLS.skip, RpMissingParentFailure),
    create_missing_parent = (CONTROLS.create, RpMissingParentFailure),
    skip_existing_new     = (CONTROLS.skip, RpExistsFailure),
    clobber_existing_new  = (CONTROLS.clobber, RpExistsFailure),
    skip_colliding_new    = (CONTROLS.skip, RpCollsionFailure),
    clobber_colliding_new = (CONTROLS.clobber, RpCollsionFailure),
    skip_failed_rename    = (CONTROLS.skip, RpRenameFailure),
    skip_failed_filter    = (CONTROLS.skip, RpFilterFailure),
    keep_failed_filter    = (CONTROLS.keep, RpFilterFailure),

FAIL:
    orig_missing              = 'Original path does not exist',
    new_exists                = 'New path exists',
    new_parent_missing        = 'Parent directory of new path does not exist',
    orig_new_same             = 'Original path and new path are the same',
    new_collision             = 'New path collides with another new path',
    no_input_paths            = 'No input paths',
    no_paths                  = 'No paths to be renamed',
    no_paths_after_processing = 'All paths were filtered out by failure control during processing',
    parsing_no_structures     = 'No input structures given',
    parsing_row               = 'The --rows option expects rows with exactly two cells: {row!r}',
    parsing_paragraphs        = 'The --paragraphs option expects exactly two paragraphs',
    parsing_inequality        = 'Got an unequal number of original paths and new paths',
    opts_require_one          = 'One of these options is required',
    opts_mutex                = 'No more than one of these options should be used',
    prepare_failed            = 'RenamingPlan cannot rename paths because failures occurred during preparation',
    rename_done_already       = 'RenamingPlan cannot rename paths because renaming has already been executed',
    conflicting_controls      = 'Conflicting controls specified for a failure type: {} and {}',
    filter_code_invalid       = 'Error in user-supplied filtering code: {} [original path: {}]',
    rename_code_invalid       = 'Error in user-supplied renaming code: {} [original path: {}]',
    rename_code_bad_return    = 'Invalid type from user-supplied renaming code: {} [original path: {}]',
    prepare_failed_cli        = 'Renaming preparation resulted in failures:{}.\n',
    renaming_raised           = '\nRenaming raised an error; some paths might have been renamed; traceback follows:\n\n{}',

