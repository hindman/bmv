--------
toc: Table of contents
--------

    toc         | Table of contents
    todos       | TODOs
    road-map    | Road map
    dev-notes   | Dev notes
    misc-notes  | Misc notes
    other-tools | Other tools

--------
todos: TODOs
--------

Support preferences.
    - switch my pager back to `less`.
    - set my editor to `mvim`.

Add --enforce and make --skip=equal the default.

Add --edit: receive original paths; open editor; user defines new paths.
    from subprocess import run
    cmd = ('mvim', 'foobar.txt')
    p = run(cmd)
    print(p)           # CompletedProcess(args=('mvim', 'foobar.txt'), returncode=0)

Case-change-only renamings.
    - Path(orig).rename(new): works
    - But existence checks do not respect case.
    - This will vary by OS.

--------
road-map: Road map
--------

Other operations:
    - copy: given old-paths, copy them to new-paths.
    - link: given old-paths (sources), create new-paths (links, soft or hard).
    - chmod: given old-paths, apply "new-path" chmod-specs to old-paths.
    - times: given old-paths, apply "new-path" time-specs to old-paths.
    - touch: given old-paths, touch them.

Additional failure control: backup.

Logging operations: list, prune.

Convenience renaming operations: evaluate:

    - In the classic rename script, these were call "rules".
    - Multiple could be applied via command-line options and parameters.

    - The rule I used almost exclusively:

        --expr PERLCODE

    - But note that classic rename usage looked more like this, where the
      PERLCODE was the first positional argument and the other positionals were
      orignal paths:

        rename PERLCODE PATH...

    - Most performed common string changes. Here are the long options on
      the `rename` installed on my MacOS. The classic rename scripts
      from the past were different.

        --append SUFFIX
        --prepend PREFIX
        --lower-case
        --upper-case
        --pipe COMMAND       # Pipe orig path to COMMAND; output becomes new path
        --subst FROM TO      # Text substitution, once per orig path.
        --subst-all FROM TO  # Same, but potentially multiple times per orig path.
        --remove-extension
        --keep-extension     # Remove ext; apply all other rules; then append ext.
        --camelcase          # Capitalize every word in the orig path.
        --urlesc             # Decode URL-escaped orig path.
        --nows               # Replace whitespace sequences with a single underscore.
        --rews               # Replace each underscore with single space.
        --noctrl             # Replace control char sequences with single underscore.
        --nometa             # Replace each shell meta-character with underscore.
        --trim               # Remove whitespace and underscores from ends of orig path.

Undo renaming, based on log.

Options:
    --row-delimiter [default: tab]
    --path-delimiter [default: newline]
    --no-strip [default: paths are stripped]

Alternative dryrun output styles:
    - same as input structures
    - plus json

Complex failure/validation scenarios:
    - prior renaming would make subsequent renaming fail [eg, changing directory path before attempting a file rename]

--------
dev-notes: Dev notes
--------

Creating a new virtualenv:

    v='3.9.4'
    deactivate
    pyenv shell $v && pyenv versions
    mkvirtualenv mvs-$v
    pip install -U pip
    pip install -e .[dev,test] && pip list

Activate and run tests:

    - Basic:

        workon mvs-3.9.4
        pytest -s -v tests/

    - With invoke:

        inv test
        inv tox

    - With tox directly:

        pyenv shell 3.9.4  3.8.9  ...
        tox

Version bump:

    - Edit/commit all changes, including CHANGES and README.

    inv bump --kind major|minor|patch

Publish:

    inv dist [--publish] [--test]

Installing from test pypi:

    pip install --index-url https://test.pypi.org/simple/ mvs

Tag file creation:

    inv tags

--------
misc-notes: Misc notes
--------

The purpose of the --paragraphs structure:

    - It does not provide any user flexibility.

    - Rather, it applies an extra component of strictness to the input parsing.

    - The paragraphs structure is the same as flat, plus the additional
      requirement that at least one blank existings between the original and
      new paths.

Adding --enforce and making --skip=equal the default:

    - What the --enforce mechanism means:

        - If the user applies --enforce=X it removes any upstream configuations
          setting a control for X.

        - The upstream configuations are the application defaults and the user
          defaults (mvs.conf).

    - Demonstration that we can achieve all configurations:

        - Assume that Problem X has applicable controls skip, parent.

        - Under every combination of application default (either no control or
          having a default control) and user default (either no change or
          applying a setting), the command-line user can still achieve all of
          the possible behaviors (enforce, skip, parent).

        App default | User default | Command-line
        ===========================================
        No control  | .            | --skip X
        "           | .            | --parent X
        -------------------------------------------
        "           | skip = X     | --parent X
        "           | skip = X     | --enforce X
        -------------------------------------------
        "           | parent = X   | --skip X
        "           | parent = X   | --enforce X
        ===========================================
        skip = X    | .            | --parent X
        "           | .            | --enforce X
        -------------------------------------------
        "           | parent = X   | --skip X
        "           | parent = X   | --enforce X
        -------------------------------------------
        "           | enforce = X  | --skip X
        "           | enforce = X  | --parent X
        ===========================================

--------
other-tools: Other tools
--------

CLI tools:

  - rename

    - http://search.cpan.org/~pederst/rename-1.9/bin/rename.PL

    - Classic Perl renaming utility by Larry Wall, subsequently maintained
      (perhaps with minor enhancements) by others.

    - The core concept was to use a Perl expression to convert ORIG names to
      NEW names.

  - brn

    - http://search.cpan.org/~swestrup/App-FileTools-BulkRename-0.07/bin/brn

    - Enhancement of the Perl rename tool.

  - perlmv

    - http://search.cpan.org/dist/App-perlmv/bin/perlmv

    - Enhancement of the Perl rename tool.

    - Scriptlets directory where a user could store small bits of renaming
      logic. On the command-line, these common scenarios could be referenced by
      name.

  - pmv

    - http://search.cpan.org/~jv/File-PerlMove-0.06/script/pmv

    - Enhancement of the Perl rename tool.

  - renameutils

    - http://www.nongnu.org/renameutils/

    - Editor mode: open candidate renamings in text file; user edits and quits;
      then renaming occurs.

  - mmv

    - Unix mass move tool. Fairly basic.

    - Very little information available aside from some archived man pages.

  - rnm

    - https://github.com/neurobin/rnm

    - Many features, but nothing I haven't covered already.

    - A long and cryptic set of options, codes, and terminology.


GUI tools and OS-specific tools:

  - pyrenamer

    - https://github.com/SteveRyherd/pyRenamer

  - gprename

    - https://en.wikipedia.org/wiki/GPRename

  - krename

    - http://www.krename.net/home/

  - Metamorphose

    - https://github.com/metamorphose/metamorphose2

