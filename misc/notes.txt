--------
toc: Table of contents
--------

    toc         | Table of contents
    todos       | TODOs
    road-map    | Road map
    dev-notes   | Dev notes
    misc-notes  | Misc notes
    other-tools | Other tools

--------
todos: TODOs
--------

Drop fake file system:

    - Modify test_plan.py:
        - Get tests working along the lines in test_structure_default().

    - Modify test_cli.py:
        - CliRenamerSio: make yes=True the default.
        - Get tests working along the lines in test_wa().

    - Remove commented-out file system code from plan.py and cli.py.

    - Assess test coverage, remaining tests, and CliRenamerSio.

Implement new checks regarding file types and clobbering [see NEW_CHECKS].

Support case-change renamings [see CASE_CHANGE].

Add --enforce and make --skip=equal the default.

Clipboard source test disabled for Linux: revive if possible.

New documentation [see NEW_DOCS].

Tests:
    - User-prefs
    - The --edit option.

Editing pass:
    - User-prefs
    - The --edit option.
    - Tests.

--------
road-map: Road map
--------

CLI.opts_config is awkward: rework.
    - The oc dicts lack a simple name attribute.
    - The opts_config collection would work better as a dict
      where you could look items up by name.
    - The special key names are a hassle.

Other operations:
    - copy: given old-paths, copy them to new-paths.
    - link: given old-paths (sources), create new-paths (links, soft or hard).
    - chmod: given old-paths, apply "new-path" chmod-specs to old-paths.
    - times: given old-paths, apply "new-path" time-specs to old-paths.
    - touch: given old-paths, touch them.

Additional failure control: backup.

Logging operations: list, prune.

Convenience renaming operations: evaluate:

    - In the classic rename script, these were call "rules".
    - Multiple could be applied via command-line options and parameters.

    - The rule I used almost exclusively:

        --expr PERLCODE

    - But note that classic rename usage looked more like this, where the
      PERLCODE was the first positional argument and the other positionals were
      orignal paths:

        rename PERLCODE PATH...

    - Most performed common string changes. Here are the long options on
      the `rename` installed on my MacOS. The classic rename scripts
      from the past were different.

        --append SUFFIX
        --prepend PREFIX
        --lower-case
        --upper-case
        --pipe COMMAND       # Pipe orig path to COMMAND; output becomes new path
        --subst FROM TO      # Text substitution, once per orig path.
        --subst-all FROM TO  # Same, but potentially multiple times per orig path.
        --remove-extension
        --keep-extension     # Remove ext; apply all other rules; then append ext.
        --camelcase          # Capitalize every word in the orig path.
        --urlesc             # Decode URL-escaped orig path.
        --nows               # Replace whitespace sequences with a single underscore.
        --rews               # Replace each underscore with single space.
        --noctrl             # Replace control char sequences with single underscore.
        --nometa             # Replace each shell meta-character with underscore.
        --trim               # Remove whitespace and underscores from ends of orig path.

Undo renaming, based on log.

Options:
    --row-delimiter [default: tab]
    --path-delimiter [default: newline]
    --no-strip [default: paths are stripped]

Alternative dryrun output styles:
    - same as input structures
    - plus json
    - could be useful if we adopt strict clobbering policy:
        - Run mvs once to figure out which clobber-victims violate policy.
        - List that information in a flat/useful way.
        - User handles those issues.
        - Then user re-runs the original mvs attempt, which should work now.

Complex failure/validation scenarios:
    - prior renaming would make subsequent renaming fail [eg, changing directory path before attempting a file rename]

--------
dev-notes: Dev notes
--------

Creating a new virtualenv:

    v='3.9.4'
    deactivate
    pyenv shell $v && pyenv versions
    mkvirtualenv mvs-$v
    pip install -U pip
    pip install -e .[dev,test] && pip list

Activate and run tests:

    - Basic:

        workon mvs-3.9.4
        pytest -s -v tests/

    - With invoke:

        inv test
        inv tox

    - With tox directly:

        pyenv shell 3.9.4  3.8.9  ...
        tox

Version bump:

    - Edit/commit all changes, including CHANGES and README.

    inv bump --kind major|minor|patch

Publish:

    inv dist [--publish] [--test]

Installing from test pypi:

    pip install --index-url https://test.pypi.org/simple/ mvs

Tag file creation:

    inv tags

--------
misc-notes: Misc notes
--------

New documentation [NEW_DOCS]:

    - New features:
        - User-prefs
        - The --edit option.

    - Bug fixes:
        - Windows replace.
        - README and argparse configuration for --create was incorrect.

    - Policy changes.

    - CHANGES file.

    - Add caveats:

        - Renaming is implemented with pathlib, which depends on os.rename()
          os.replace().

        - Renames across file systems can fail according to those docs.

        - Be sensible.

            - If you have a lot of renaming to do involving complex scenarios (eg
              files replacing nonempty dirs), break it down into more sane steps.

            - Don't rename stuff that could affect the ability of subsequent
              renames to succeed. The mvs library checks the renaming plan against
              the current file system: it does not check each rename against the
              future file system after some renamings have occurred.

Case-change renamings [CASE_CHANGE]:

    - Function to determine a path's existence status:

        PS = PATH_STATUSES = constants('PathStatuses', dict(
            missing = 0,
            exists = 1,
            exists_strict = 2,
        ))

        def path_existence(path):
            p = Path(p)
            if p.parent.exists():
                if p in p.parent.iterdir():
                    return PS.exists_strict
                elif p.exists():
                    return PS.exists
            return PS.missing

    - How the RenamePair existence checks should operate:

        check_orig_exists():
            - Key question: is renaming possible?
            - PS.exists is sufficient.

        check_new_not_exists():
            - Key question: is renaming necessary?
            - Requires PS.exists_strict.

        check_new_parent_exists():
            - Key question: does renaming also require create-parent?
            - PS.exists is sufficient.

    - Tests should cover all possibilities:

        parent    | name      | Example: orig vs new | Note
        ---------------------------------------------------------------------
        eq        | eq        | foo/bar   foo/bar    | .
        "         | case      | foo/bar   foo/BAR    | .
        "         | different | foo/bar   foo/b      | .
        case      | eq        | foo/bar   FOO/bar    | .
        "         | case      | foo/bar   FOO/BAR    | .
        "         | different | foo/bar   FOO/b      | .
        different | eq        | foo/bar   f/bar      | .
        "         | case      | foo/bar   f/BAR      | .
        "         | different | foo/bar   f/b        | .

Current file system interactions:

    - cli.py
        - Path.home().
        - Read user-prefs.
        - Write log.
        - Read input paths from file.
        - Editing input paths in editor.

    - plan.py
        - Check path existence.
        - Create directory during renaming.
        - Renaming.

New checks: file types and clobbering [NEW_CHECKS]:

    - Orig paths must be regular file or directory.

    - In clobbering, like must overwrite like:
        file => file
        dir => dir

    - To-be-clobbered directories, must be empty.

The purpose of the --paragraphs structure:

    - It does not provide any user flexibility.

    - Rather, it applies an extra component of strictness to the input parsing.

    - The paragraphs structure is the same as flat, plus the additional
      requirement that at least one blank existings between the original and
      new paths.

Adding --enforce and making --skip=equal the default:

    - What the --enforce mechanism means:

        - If the user applies --enforce=X it removes any upstream configuations
          setting a control for X.

        - The upstream configuations are the application defaults and the user
          defaults (mvs.conf).

    - Demonstration that we can achieve all configurations:

        - Assume that Problem X has applicable controls skip, parent.

        - Under every combination of application default (either no control or
          having a default control) and user default (either no change or
          applying a setting), the command-line user can still achieve all of
          the possible behaviors (enforce, skip, parent).

        App default | User default | Command-line
        ===========================================
        No control  | .            | --skip X
        "           | .            | --parent X
        -------------------------------------------
        "           | skip = X     | --parent X
        "           | skip = X     | --enforce X
        -------------------------------------------
        "           | parent = X   | --skip X
        "           | parent = X   | --enforce X
        ===========================================
        skip = X    | .            | --parent X
        "           | .            | --enforce X
        -------------------------------------------
        "           | parent = X   | --skip X
        "           | parent = X   | --enforce X
        -------------------------------------------
        "           | enforce = X  | --skip X
        "           | enforce = X  | --parent X
        ===========================================

How --edit relates to SOURCES and STRUCTURES:

    - The --edit option is like a "source" and has structural implications, but
      it not literally a source or a structure.

    - Source:

        - The option is not a primary source. Instead, the user provides
          original paths from a primary source.

        - Like --rename, --edit augments those paths. But unlike --rename, the
          augmentation occur before path parsing. So the steps go like this:

            - Read input from source (orig paths)
            - Write paths to temp file.
            - Edit temp file.
            - Read input paths from temp file (orig paths and new paths).
            - Parse.

    - Structure:

        - Both --edit and --rename have structural implications.

        - But --rename functions as a STRUCTURE in command-line grammar becaue
          it means the user need not (and cannot meaningfully) specify a
          structure other than the default of --flat.

        - By contrast, a user can use --edit and any of the structures. The
          --edit option assumes that the input input paths are flat and solely
          original; but the final edited temp file can have any structure the
          user wants.

Policy regarding new parents:

    - If user requests parent-affecting rename, what is intended?

        foo/bar.txt => FOO/bar-new.txt

    - Does user want to create FOO or rename foo to FOO?

        - If create is intended, it would work only on the case-sensistive
          systems that allow foo and FOO to coexist.

        - If rename is intended, that would affect the unlisted siblings of the
          original path.

            - That seems like a significant operation to infer with certaintly
              from a file rename request.

            - By contrast, an explicitly requested directory rename is known to
              affect all of its contents. But contents and siblings are
              different.

    - Policy to avoid that complexity and ambiguity:

        - Parents can be created but not renamed.

    - How mvs would behave in the current example:

        OS case-sensitive | Action
        -----------------------------------------------
        Yes               | Create missing FOO
        No                | Do nothing since FOO exists

        - In other words, create parent only if the user requests it and if the
          file system says the parent is missing.

Why I dropped the fake file system:

    - Path renaming is too complex to test well via a fake:

        - There are many complications, varying by OS, with renaming alone.

        - The number of file system operations is already non-trivial and, in
          future changes, I might add others.

    - I decided to mitigate the complexity in three ways:

        - Stricter policy about supported file types.
        - Stricter policy about clobbering.
        - Commit to writing real tests with actual renaming.

--------
other-tools: Other tools
--------

CLI tools:

  - rename

    - http://search.cpan.org/~pederst/rename-1.9/bin/rename.PL

    - Classic Perl renaming utility by Larry Wall, subsequently maintained
      (perhaps with minor enhancements) by others.

    - The core concept was to use a Perl expression to convert ORIG names to
      NEW names.

  - brn

    - http://search.cpan.org/~swestrup/App-FileTools-BulkRename-0.07/bin/brn

    - Enhancement of the Perl rename tool.

  - perlmv

    - http://search.cpan.org/dist/App-perlmv/bin/perlmv

    - Enhancement of the Perl rename tool.

    - Scriptlets directory where a user could store small bits of renaming
      logic. On the command-line, these common scenarios could be referenced by
      name.

  - pmv

    - http://search.cpan.org/~jv/File-PerlMove-0.06/script/pmv

    - Enhancement of the Perl rename tool.

  - renameutils

    - http://www.nongnu.org/renameutils/

    - Editor mode: open candidate renamings in text file; user edits and quits;
      then renaming occurs.

  - mmv

    - Unix mass move tool. Fairly basic.

    - Very little information available aside from some archived man pages.

  - rnm

    - https://github.com/neurobin/rnm

    - Many features, but nothing I haven't covered already.

    - A long and cryptic set of options, codes, and terminology.


GUI tools and OS-specific tools:

  - pyrenamer

    - https://github.com/SteveRyherd/pyRenamer

  - gprename

    - https://en.wikipedia.org/wiki/GPRename

  - krename

    - http://www.krename.net/home/

  - Metamorphose

    - https://github.com/metamorphose/metamorphose2

