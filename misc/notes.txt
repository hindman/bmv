--------
toc: Table of contents
--------

    toc         | Table of contents
    todos       | TODOs
    road-map    | Road map
    dev-notes   | Dev notes
    misc-notes  | Misc notes
    other-tools | Other tools

--------
todos: TODOs
--------

Fix bug in check_new_exists():

    - Write tests for new code and new Problem types.

        - test_case_clobber() works but does not test things the way we would
          want to.

Fix bug on case-preserving systems:

    - Clobbering can end up inherting casing of existing path.

    - Example on MacOS:

        touch a B
        mvs a b --yes     # Result: B

    - Modify do_rename() to achieve to things:

        - Fix the bug.

        - Add a final layer of insurance so that clobbering never
          occurs without request.

        # If new path exists already, deal with it.
        pnew = Path(rp.new)
        if pnew.exists():
            if rp.clobber:
                # Don't inherit casing from clobbered path.
                if rp.type_orig == FILE_TYPES.file:
                    pnew.unlink()
                else:
                    pnew.rmdir()
            else:
                # Don't clobber unless requested.
                raise ...

        # Rename orig => new.
        Path(rp.orig).rename(rp.new)

Fix the check for new-collisions:

    - Checks for collisions among new paths is done in a case-sensitive
      way. So new-collisions among 'foo' and 'FOO' won't be reported as
      problems.

    - Based on this example, it looks like the renaming "succeeds" and
      paths are clobbered silently [because Path.rename() allows silent
      clobbering on Unix and MacOS if the user has sufficient permissions.]

        mvs a b c x y Y

        a => x
        b => y    # Now y exists.
        c => y    # Path stays lowercase, but it assumes the content of file c.

    - Fix: implement case_sensistive_file_sys():

        - True: use rp.new as dict key.
        - False: use rp.new.lower().

    - See SO question to determine type of file system:

        https://stackoverflow.com/questions/7870041/check-if-file-system-is-case-insensitive-in-python

        - Because some systems allow different settings per directory,
          there is no perfect approach.

        - But there are some relatively easy checks that could be used to
          make a good attempt.

        - Add this issue in the caveats of the documentation.

Implement: only empty directories can be clobbered.

    - See test_new_exists_non_empty() for partial progress
      on a test for the behavior.

Tests:

    x Clobbering: like can clobber like.
    x Orig paths must be regular file or directory.
    x Change --editor and --pager back to str:
    x Skip-equal as default: check that it is covered by tests [I think so].
    x The --edit option.
    x Refactor test_cli.py to use run_checks(): see docstring.
    x Bug fix: Windows replace.
    x Double check pragma-no-cover stuff.
    x User-prefs: exercise code once with ENV var unset.

    - Case-change renamings [see table below].

    parent    | name      | Example: orig vs new | Note
    ---------------------------------------------------------------------
    eq        | eq        | foo/bar   foo/bar    | .
    "         | case      | foo/bar   foo/BAR    | .
    "         | different | foo/bar   foo/b      | .
    case      | eq        | foo/bar   FOO/bar    | .
    "         | case      | foo/bar   FOO/BAR    | .
    "         | different | foo/bar   FOO/b      | .
    different | eq        | foo/bar   f/bar      | .
    "         | case      | foo/bar   f/BAR      | .
    "         | different | foo/bar   f/b        | .

New documentation [see NEW_DOCS].

Editing pass [see NEW_DOCS].

Publish with major version bump.

--------
road-map: Road map
--------

Clipboard source test disabled for Linux: revive if possible.

Support sym-link renames.

Other operations: copy, link, chmod, times, touch [see OTHER_OPS].

Additional failure control: backup [see CONTROL_BACKUP].

Logging operations: list, prune.

Convenience renaming operations [see CONVENIENCE_OPS].

Undo renaming, based on log.

New inputs options: delimiters and stripping [see INPUT_OPTS].

Alternative dryrun output styles [see DRYRUN_OUTPUTS].

Complex failure/validation scenarios [see COMPLEX_SCENARIOS].

--------
dev-notes: Dev notes
--------

Creating a new virtualenv:

    v='3.9.4'
    deactivate
    pyenv shell $v && pyenv versions
    mkvirtualenv mvs-$v
    pip install -U pip
    pip install -e .[dev,test] && pip list

Activate and run tests:

    - Basic:

        workon mvs-3.9.4
        pytest -s -v tests/

    - With invoke:

        inv test
        inv tox

    - With tox directly:

        pyenv shell 3.9.4  3.8.9  ...
        tox

Version bump:

    - Edit/commit all changes, including CHANGES and README.

    inv bump --kind major|minor|patch

Publish:

    inv dist [--publish] [--test]

Installing from test pypi:

    pip install --index-url https://test.pypi.org/simple/ mvs

Tag file creation:

    inv tags

--------
misc-notes: Misc notes
--------

New documentation [NEW_DOCS]:

    - Don't delete this until just before publish.

    - New features:
        - User-prefs
        - The --edit option.
        - New problem control API.
        - skip-equal as default
        - case-change renamings

    - Bug fixes:
        - Windows replace.
        - README and argparse configuration for --create was incorrect.

    - Policy changes.
        - Orig paths must be regular file or directory.
        - In clobbering, like must overwrite like (file => file; dir => dir).
        - Only empty directories can be clobbered.
        - The --create control will create parents, not move-create.
        - New Problem('same')
            - This less strong variant of Problem('equal').
            - equal speaks to user input: did user ask for renaming of this rp?
            - same speaks to whether renaming is supported by the policies of mvs.
        - New Problem('recase')
            - skipped by default
            - affects only case-preserving systems

    - Document that --pager and --editor are executed with shell=True.

    - CHANGES file.

    - Add caveats:

        - Renaming is implemented with pathlib, which depends on os.rename()
          os.replace().

        - Renames across file systems can fail according to those docs.

        - Be sensible.

            - If you have a lot of renaming to do involving complex scenarios (eg
              files replacing nonempty dirs), break it down into more sane steps.

            - Don't rename stuff that could affect the ability of subsequent
              renames to succeed. The mvs library checks the renaming plan against
              the current file system: it does not check each rename against the
              future file system after some renamings have occurred.

        - The package is not tested on case-sensitive and case-preserving
          operating systems, but not on case-insensitive systems. In that
          context, regular renamings will probably work fine. Some
          case-change-only renamings won't be treated as problems by the checks
          (if rp.new fails to exists-strict), so the renaming would be tried,
          and it will fail.

        - Renaming renames the leaf, not the leaf plus its parent. When
          renaming something, mvs asks whether the parent of its new path
          exists.

            - If yes, then the renaming does not need to concern itself with
              the parent and the renaming affects only the leaf node.

            - If no, then the renaming will be refused unless the user requests
              create-parent and, if so, the new-parent is created. The
              old-parent will be unchanged.

            - That behavior is reasonable: old-parent might contain other stuff
              and mvs was not instructed modify it.

            - And it most renaming scenarios, the behavior is not surprising
              or counter-intuitive.

Other operations: copy, link, chmod, times, touch [OTHER_OPS]:
    - copy: given old-paths, copy them to new-paths.
    - link: given old-paths (sources), create new-paths (links, soft or hard) pointing to old-paths.
    - chmod: given old-paths, apply "new-path" chmod-specs to old-paths.
    - times: given old-paths, apply "new-path" time-specs to old-paths.
    - touch: given old-paths, touch them.

Additional failure control: backup [CONTROL_BACKUP]:
    - Before clobber, backup the target (foo => foo.bak).
    - Which really just adds a supplement renaming.

New inputs options: delimiters and stripping [INPUT_OPTS]:
    --row-delimiter [default: tab]
    --path-delimiter [default: newline]
    --no-strip [default: paths are stripped]

Alternative dryrun output styles [DRYRUN_OUTPUTS]:
    - same as input structures
    - plus json
    - could be useful if we adopt strict clobbering policy:
        - Run mvs once to figure out which clobber-victims violate policy.
        - List that information in a flat/useful way.
        - User handles those issues.
        - Then user re-runs the original mvs attempt, which should work now.

Complex failure/validation scenarios [COMPLEX_SCENARIOS]:

    - prior renaming would make subsequent renaming fail [eg, changing
      directory path before attempting a file rename]

Convenience renaming operations [CONVENIENCE_OPS]:

    - Evaluate these ideas and make plan (or drop).

    - In the classic rename script, these were call "rules". Multiple could be
      applied via command-line options and parameters. I think they were
      executed in order.

    - The rule I used almost exclusively:

        --expr PERLCODE

    - But note that classic rename usage looked more like this, where the
      PERLCODE was the first positional argument and the other positionals were
      orignal paths:

        rename PERLCODE PATH...

    - Most performed common string changes. Here are the long options on
      the `rename` installed on my MacOS. The classic rename scripts
      from the past were different.

        --append SUFFIX
        --prepend PREFIX
        --lower-case
        --upper-case
        --pipe COMMAND       # Pipe orig path to COMMAND; output becomes new path
        --subst FROM TO      # Text substitution, once per orig path.
        --subst-all FROM TO  # Same, but potentially multiple times per orig path.
        --remove-extension
        --keep-extension     # Remove ext; apply all other rules; then append ext.
        --camelcase          # Capitalize every word in the orig path.
        --urlesc             # Decode URL-escaped orig path.
        --nows               # Replace whitespace sequences with a single underscore.
        --rews               # Replace each underscore with single space.
        --noctrl             # Replace control char sequences with single underscore.
        --nometa             # Replace each shell meta-character with underscore.
        --trim               # Remove whitespace and underscores from ends of orig path.

Current file system interactions:

    - This is outdated.

    - cli.py
        - Path.home().
        - Read user-prefs.
        - Write log.
        - Read input paths from file.
        - Editing input paths in editor.

    - plan.py
        - Check path existence.
        - Create directory during renaming.
        - Renaming.

The purpose of the --paragraphs structure:

    - It does not provide any user flexibility.

    - Rather, it applies an extra component of strictness to the input parsing.

    - The paragraphs structure is the same as flat, plus the additional
      requirement that at least one blank existings between the original and
      new paths.

How --edit relates to SOURCES and STRUCTURES:

    - The --edit option is like a "source" and has structural implications, but
      it not literally a source or a structure.

    - Source:

        - The option is not a primary source. Instead, the user provides
          original paths from a primary source.

        - Like --rename, --edit augments those paths. But unlike --rename, the
          augmentation occur before path parsing. So the steps go like this:

            - Read input from source (orig paths)
            - Write paths to temp file.
            - Edit temp file.
            - Read input paths from temp file (orig paths and new paths).
            - Parse.

    - Structure:

        - Both --edit and --rename have structural implications.

        - But --rename functions as a STRUCTURE in command-line grammar becaue
          it means the user need not (and cannot meaningfully) specify a
          structure other than the default of --flat.

        - By contrast, a user can use --edit and any of the structures. The
          --edit option assumes that the input input paths are flat and solely
          original; but the final edited temp file can have any structure the
          user wants.

Policy regarding new parents:

    - If user requests parent-affecting rename, what is intended?

        foo/bar.txt => FOO/bar-new.txt

    - Does user want to create FOO or rename foo to FOO?

        - If create is intended, it would work only on the case-sensistive
          systems that allow foo and FOO to coexist.

        - If rename is intended, that would affect the unlisted siblings of the
          original path.

            - That seems like a significant operation to infer with certaintly
              from a file rename request.

            - By contrast, an explicitly requested directory rename is known to
              affect all of its contents. But contents and siblings are
              different.

    - Policy to avoid that complexity and ambiguity:

        - Parents can be created but not renamed.

    - How mvs would behave in the current example:

        OS case-sensitive | Action
        -----------------------------------------------
        Yes               | Create missing FOO
        No                | Do nothing since FOO exists

        - In other words, create parent only if the user requests it and if the
          file system says the parent is missing.

Why I dropped the fake file system:

    - Path renaming is too complex to test well via a fake:

        - There are many complications, varying by OS, with renaming alone.

        - The number of file system operations is already non-trivial and, in
          future changes, I might add others.

    - I decided to mitigate the complexity in three ways:

        - Stricter policy about supported file types.
        - Stricter policy about clobbering.
        - Commit to writing real tests with actual renaming.

Checking for the existence of RenamePair.new:

    - Start with some simplifying assumptions:

        - rp.orig exists: this problem is handled in a separate problem check.

        - rp.orig and rp.new are equal: we can handle this at the outset of the
          check_new_exists().

        - rp.new exists in some sense: if it does not, the situation is simple
          and we can rename freely. Handle this check at the outset.

        - The file system is case-preserving. This type of system involves the
          most complexity. Case-sensistive and case-insensitive systems have
          much simpler logic to determine whether clobbering would occur.
          Handle the latter at the outset.

    - Classification table for case-preserving systems, given the assumptions:

        - Columns:
            - Do rp.orig and rp.new have the same parents: will renaming require re-locate?
            - Does file-name casing of rp.new already agree with a file that exists on file system?
            - What type of change did the user request for the file-name portion?

        - Table:

            Re-locate | NameAgrees | NameChange | Notes
            ---------------------------------------------------------------------
            Yes       | No         | re-name    | #1 Clobber differently-cased name.
            "         | "          | re-case    | #2 "
            "         | "          | .          | #3 "
            "         | Yes        | re-name    | #4 Clobber.
            "         | "          | re-case    | #5 "
            "         | "          | .          | #6 "
            No        | No         | re-name    | #7 Clobber differently-cased name.
            "         | "          | re-case    | #8 Case-change-only renaming (self clobber).
            "         | "          | .          | #9 Problem(same).
            "         | Yes        | re-name    | #10 Clobber.
            "         | "          | re-case    | #11 Problem(recase).
            "         | "          | .          | #12 Problem(same).

        Examples for each table row:

            Path | re-name     | re-case     | noop
            ================================================
            orig | foo/xyz #1  | foo/xyz #2  | foo/xyz #3
            new  | BAR/xy      | BAR/XYz     | BAR/xyz
            fsys | BAR/xY      | BAR/xyZ     | BAR/xyZ
            ------------------------------------------------
            orig | foo/xyz #4  | foo/xyZ #5  | foo/xyz #6
            new  | BAR/xy      | BAR/xyz     | BAR/xyz
            fsys | BAR/xy      | BAR/xyz     | BAR/xyz
            ================================================
            orig | foo/xyz #7  | foo/xyz #8  | foo/xyz #9
            new  | foo/xy      | foo/XYZ     | FOO/xyz
            fsys | foo/xY      | foo/xyz     | foo/xyZ
            ------------------------------------------------
            orig | foo/xyz #10 | foo/xyZ #11 | FOO/xyz #12
            new  | foo/xy      | foo/xyz     | foo/xyz
            fsys | foo/xy      | foo/xyz     | foo/xyz

--------
other-tools: Other tools
--------

CLI tools:

  - rename

    - http://search.cpan.org/~pederst/rename-1.9/bin/rename.PL

    - Classic Perl renaming utility by Larry Wall, subsequently maintained
      (perhaps with minor enhancements) by others.

    - The core concept was to use a Perl expression to convert ORIG names to
      NEW names.

  - brn

    - http://search.cpan.org/~swestrup/App-FileTools-BulkRename-0.07/bin/brn

    - Enhancement of the Perl rename tool.

  - perlmv

    - http://search.cpan.org/dist/App-perlmv/bin/perlmv

    - Enhancement of the Perl rename tool.

    - Scriptlets directory where a user could store small bits of renaming
      logic. On the command-line, these common scenarios could be referenced by
      name.

  - pmv

    - http://search.cpan.org/~jv/File-PerlMove-0.06/script/pmv

    - Enhancement of the Perl rename tool.

  - renameutils

    - http://www.nongnu.org/renameutils/

    - Editor mode: open candidate renamings in text file; user edits and quits;
      then renaming occurs.

  - mmv

    - Unix mass move tool. Fairly basic.

    - Very little information available aside from some archived man pages.

  - rnm

    - https://github.com/neurobin/rnm

    - Many features, but nothing I haven't covered already.

    - A long and cryptic set of options, codes, and terminology.


GUI tools and OS-specific tools:

  - pyrenamer

    - https://github.com/SteveRyherd/pyRenamer

  - gprename

    - https://en.wikipedia.org/wiki/GPRename

  - krename

    - http://www.krename.net/home/

  - Metamorphose

    - https://github.com/metamorphose/metamorphose2

